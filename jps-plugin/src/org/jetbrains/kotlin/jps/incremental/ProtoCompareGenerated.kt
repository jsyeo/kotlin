/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.jps.incremental

import org.jetbrains.kotlin.serialization.ProtoBuf
import org.jetbrains.kotlin.serialization.deserialization.NameResolver
import org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf
import java.util.EnumSet

/** This file is generated by org.jetbrains.kotlin.generators.protobuf.GenerateProtoBufCompare. DO NOT MODIFY MANUALLY */


public data class ProtoBufPackage(
    public val memberList: List<ProtoBufCallable>
) {
    public enum class Kind {
        MEMBER_LIST
    }
}

public fun ProtoBuf.Package.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufPackage {
    val memberList = this.memberList.map { it.toDataClass(nameResolver, enumerate) }
    return ProtoBufPackage(memberList)
}

public fun ProtoBufPackage.differenceTo(other: ProtoBufPackage): EnumSet<ProtoBufPackage.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufPackage.Kind>())

    if (memberList != other.memberList) {
        result.add(ProtoBufPackage.Kind.MEMBER_LIST)
    }

    return result
}

public data class ProtoBufClass(
    public val flags: Int?,
    public val fqName: Int,
    public val companionObjectName: Int?,
    public val typeParameterList: List<ProtoBufTypeParameter>,
    public val supertypeList: List<ProtoBufType>,
    public val nestedClassNameList: List<Int>,
    public val memberList: List<ProtoBufCallable>,
    public val enumEntryList: List<Int>,
    public val primaryConstructor: ProtoBufClassPrimaryConstructor?,
    public val secondaryConstructorList: List<ProtoBufCallable>,
    public val classAnnotationList: List<ProtoBufAnnotation>
) {
    public enum class Kind {
        FLAGS,
        FQ_NAME,
        COMPANION_OBJECT_NAME,
        TYPE_PARAMETER_LIST,
        SUPERTYPE_LIST,
        NESTED_CLASS_NAME_LIST,
        MEMBER_LIST,
        ENUM_ENTRY_LIST,
        PRIMARY_CONSTRUCTOR,
        SECONDARY_CONSTRUCTOR_LIST,
        CLASS_ANNOTATION_LIST
    }
}

public fun ProtoBuf.Class.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufClass {
    val flags = if (hasFlags()) this.flags else null
    val fqName = this.fqName.fromFqNameId(nameResolver, enumerate)
    val companionObjectName = if (hasCompanionObjectName()) this.companionObjectName.fromNameId(nameResolver, enumerate) else null
    val typeParameterList = this.typeParameterList.map { it.toDataClass(nameResolver, enumerate) }
    val supertypeList = this.supertypeList.map { it.toDataClass(nameResolver, enumerate) }
    val nestedClassNameList = this.nestedClassNameList.map { it.fromNameId(nameResolver, enumerate) }
    val memberList = this.memberList.map { it.toDataClass(nameResolver, enumerate) }
    val enumEntryList = this.enumEntryList.map { it.fromNameId(nameResolver, enumerate) }
    val primaryConstructor = if (hasPrimaryConstructor()) this.primaryConstructor.toDataClass(nameResolver, enumerate) else null
    val secondaryConstructorList = this.secondaryConstructorList.map { it.toDataClass(nameResolver, enumerate) }
    val classAnnotationList = arrayListOf<ProtoBufAnnotation>()
    for(i in 0..getExtensionCount(JvmProtoBuf.classAnnotation) - 1) {
        classAnnotationList.add(getExtension(JvmProtoBuf.classAnnotation, i).toDataClass(nameResolver, enumerate))
    }

    return ProtoBufClass(flags, fqName, companionObjectName, typeParameterList, supertypeList, nestedClassNameList, memberList, enumEntryList, primaryConstructor, secondaryConstructorList, classAnnotationList)
}

public fun ProtoBufClass.differenceTo(other: ProtoBufClass): EnumSet<ProtoBufClass.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufClass.Kind>())

    if (flags != other.flags) {
        result.add(ProtoBufClass.Kind.FLAGS)
    }

    if (fqName != other.fqName) {
        result.add(ProtoBufClass.Kind.FQ_NAME)
    }

    if (companionObjectName != other.companionObjectName) {
        result.add(ProtoBufClass.Kind.COMPANION_OBJECT_NAME)
    }

    if (typeParameterList != other.typeParameterList) {
        result.add(ProtoBufClass.Kind.TYPE_PARAMETER_LIST)
    }

    if (supertypeList != other.supertypeList) {
        result.add(ProtoBufClass.Kind.SUPERTYPE_LIST)
    }

    if (nestedClassNameList != other.nestedClassNameList) {
        result.add(ProtoBufClass.Kind.NESTED_CLASS_NAME_LIST)
    }

    if (memberList != other.memberList) {
        result.add(ProtoBufClass.Kind.MEMBER_LIST)
    }

    if (enumEntryList != other.enumEntryList) {
        result.add(ProtoBufClass.Kind.ENUM_ENTRY_LIST)
    }

    if (primaryConstructor != other.primaryConstructor) {
        result.add(ProtoBufClass.Kind.PRIMARY_CONSTRUCTOR)
    }

    if (secondaryConstructorList != other.secondaryConstructorList) {
        result.add(ProtoBufClass.Kind.SECONDARY_CONSTRUCTOR_LIST)
    }

    if (classAnnotationList != other.classAnnotationList) {
        result.add(ProtoBufClass.Kind.CLASS_ANNOTATION_LIST)
    }

    return result
}

public data class ProtoBufCallable(
    public val flags: Int?,
    public val getterFlags: Int?,
    public val setterFlags: Int?,
    public val typeParameterList: List<ProtoBufTypeParameter>,
    public val receiverType: ProtoBufType?,
    public val name: Int,
    public val valueParameterList: List<ProtoBufCallableValueParameter>,
    public val returnType: ProtoBufType,
    public val methodSignature: JvmProtoBufJvmMethodSignature?,
    public val propertySignature: JvmProtoBufJvmPropertySignature?,
    public val implClassName: Int?
) {
    public enum class Kind {
        FLAGS,
        GETTER_FLAGS,
        SETTER_FLAGS,
        TYPE_PARAMETER_LIST,
        RECEIVER_TYPE,
        NAME,
        VALUE_PARAMETER_LIST,
        RETURN_TYPE,
        METHOD_SIGNATURE,
        PROPERTY_SIGNATURE,
        IMPL_CLASS_NAME
    }
}

public fun ProtoBuf.Callable.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufCallable {
    val flags = if (hasFlags()) this.flags else null
    val getterFlags = if (hasGetterFlags()) this.getterFlags else null
    val setterFlags = if (hasSetterFlags()) this.setterFlags else null
    val typeParameterList = this.typeParameterList.map { it.toDataClass(nameResolver, enumerate) }
    val receiverType = if (hasReceiverType()) this.receiverType.toDataClass(nameResolver, enumerate) else null
    val name = this.name.fromNameId(nameResolver, enumerate)
    val valueParameterList = this.valueParameterList.map { it.toDataClass(nameResolver, enumerate) }
    val returnType = this.returnType.toDataClass(nameResolver, enumerate)
    val methodSignature = if (hasExtension(JvmProtoBuf.methodSignature)) this.getExtension(JvmProtoBuf.methodSignature).toDataClass(nameResolver, enumerate) else null
    val propertySignature = if (hasExtension(JvmProtoBuf.propertySignature)) this.getExtension(JvmProtoBuf.propertySignature).toDataClass(nameResolver, enumerate) else null
    val implClassName = if (hasExtension(JvmProtoBuf.implClassName)) this.getExtension(JvmProtoBuf.implClassName).fromNameId(nameResolver, enumerate) else null
    return ProtoBufCallable(flags, getterFlags, setterFlags, typeParameterList, receiverType, name, valueParameterList, returnType, methodSignature, propertySignature, implClassName)
}

public fun ProtoBufCallable.differenceTo(other: ProtoBufCallable): EnumSet<ProtoBufCallable.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufCallable.Kind>())

    if (flags != other.flags) {
        result.add(ProtoBufCallable.Kind.FLAGS)
    }

    if (getterFlags != other.getterFlags) {
        result.add(ProtoBufCallable.Kind.GETTER_FLAGS)
    }

    if (setterFlags != other.setterFlags) {
        result.add(ProtoBufCallable.Kind.SETTER_FLAGS)
    }

    if (typeParameterList != other.typeParameterList) {
        result.add(ProtoBufCallable.Kind.TYPE_PARAMETER_LIST)
    }

    if (receiverType != other.receiverType) {
        result.add(ProtoBufCallable.Kind.RECEIVER_TYPE)
    }

    if (name != other.name) {
        result.add(ProtoBufCallable.Kind.NAME)
    }

    if (valueParameterList != other.valueParameterList) {
        result.add(ProtoBufCallable.Kind.VALUE_PARAMETER_LIST)
    }

    if (returnType != other.returnType) {
        result.add(ProtoBufCallable.Kind.RETURN_TYPE)
    }

    if (methodSignature != other.methodSignature) {
        result.add(ProtoBufCallable.Kind.METHOD_SIGNATURE)
    }

    if (propertySignature != other.propertySignature) {
        result.add(ProtoBufCallable.Kind.PROPERTY_SIGNATURE)
    }

    if (implClassName != other.implClassName) {
        result.add(ProtoBufCallable.Kind.IMPL_CLASS_NAME)
    }

    return result
}

public data class ProtoBufTypeParameter(
    public val id: Int,
    public val name: Int,
    public val reified: Boolean?,
    public val variance: ProtoBuf.TypeParameter.Variance?,
    public val upperBoundList: List<ProtoBufType>
) {
    public enum class Kind {
        ID,
        NAME,
        REIFIED,
        VARIANCE,
        UPPER_BOUND_LIST
    }
}

public fun ProtoBuf.TypeParameter.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufTypeParameter {
    val id = this.id
    val name = this.name.fromNameId(nameResolver, enumerate)
    val reified = if (hasReified()) this.reified else null
    val variance = if (hasVariance()) this.variance else null
    val upperBoundList = this.upperBoundList.map { it.toDataClass(nameResolver, enumerate) }
    return ProtoBufTypeParameter(id, name, reified, variance, upperBoundList)
}

public fun ProtoBufTypeParameter.differenceTo(other: ProtoBufTypeParameter): EnumSet<ProtoBufTypeParameter.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufTypeParameter.Kind>())

    if (id != other.id) {
        result.add(ProtoBufTypeParameter.Kind.ID)
    }

    if (name != other.name) {
        result.add(ProtoBufTypeParameter.Kind.NAME)
    }

    if (reified != other.reified) {
        result.add(ProtoBufTypeParameter.Kind.REIFIED)
    }

    if (variance != other.variance) {
        result.add(ProtoBufTypeParameter.Kind.VARIANCE)
    }

    if (upperBoundList != other.upperBoundList) {
        result.add(ProtoBufTypeParameter.Kind.UPPER_BOUND_LIST)
    }

    return result
}

public data class ProtoBufType(
    public val argumentList: List<ProtoBufTypeArgument>,
    public val nullable: Boolean?,
    public val flexibleTypeCapabilitiesId: Int?,
    public val flexibleUpperBound: ProtoBufType?,
    public val constructorClassName: Int?,
    public val constructorTypeParameter: Int?,
    public val typeAnnotationList: List<ProtoBufAnnotation>,
    public val isRaw: Boolean?
) {
    public enum class Kind {
        ARGUMENT_LIST,
        NULLABLE,
        FLEXIBLE_TYPE_CAPABILITIES_ID,
        FLEXIBLE_UPPER_BOUND,
        CONSTRUCTOR_CLASS_NAME,
        CONSTRUCTOR_TYPE_PARAMETER,
        TYPE_ANNOTATION_LIST,
        IS_RAW
    }
}

public fun ProtoBuf.Type.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufType {
    val argumentList = this.argumentList.map { it.toDataClass(nameResolver, enumerate) }
    val nullable = if (hasNullable()) this.nullable else null
    val flexibleTypeCapabilitiesId = if (hasFlexibleTypeCapabilitiesId()) this.flexibleTypeCapabilitiesId.fromStringId(nameResolver, enumerate) else null
    val flexibleUpperBound = if (hasFlexibleUpperBound()) this.flexibleUpperBound.toDataClass(nameResolver, enumerate) else null
    val constructorClassName = if (hasConstructorClassName()) this.constructorClassName.fromFqNameId(nameResolver, enumerate) else null
    val constructorTypeParameter = if (hasConstructorTypeParameter()) this.constructorTypeParameter else null
    val typeAnnotationList = arrayListOf<ProtoBufAnnotation>()
    for(i in 0..getExtensionCount(JvmProtoBuf.typeAnnotation) - 1) {
        typeAnnotationList.add(getExtension(JvmProtoBuf.typeAnnotation, i).toDataClass(nameResolver, enumerate))
    }

    val isRaw = if (hasExtension(JvmProtoBuf.isRaw)) this.getExtension(JvmProtoBuf.isRaw) else null
    return ProtoBufType(argumentList, nullable, flexibleTypeCapabilitiesId, flexibleUpperBound, constructorClassName, constructorTypeParameter, typeAnnotationList, isRaw)
}

public fun ProtoBufType.differenceTo(other: ProtoBufType): EnumSet<ProtoBufType.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufType.Kind>())

    if (argumentList != other.argumentList) {
        result.add(ProtoBufType.Kind.ARGUMENT_LIST)
    }

    if (nullable != other.nullable) {
        result.add(ProtoBufType.Kind.NULLABLE)
    }

    if (flexibleTypeCapabilitiesId != other.flexibleTypeCapabilitiesId) {
        result.add(ProtoBufType.Kind.FLEXIBLE_TYPE_CAPABILITIES_ID)
    }

    if (flexibleUpperBound != other.flexibleUpperBound) {
        result.add(ProtoBufType.Kind.FLEXIBLE_UPPER_BOUND)
    }

    if (constructorClassName != other.constructorClassName) {
        result.add(ProtoBufType.Kind.CONSTRUCTOR_CLASS_NAME)
    }

    if (constructorTypeParameter != other.constructorTypeParameter) {
        result.add(ProtoBufType.Kind.CONSTRUCTOR_TYPE_PARAMETER)
    }

    if (typeAnnotationList != other.typeAnnotationList) {
        result.add(ProtoBufType.Kind.TYPE_ANNOTATION_LIST)
    }

    if (isRaw != other.isRaw) {
        result.add(ProtoBufType.Kind.IS_RAW)
    }

    return result
}

public data class ProtoBufClassPrimaryConstructor(
    public val data: ProtoBufCallable?
) {
    public enum class Kind {
        DATA
    }
}

public fun ProtoBuf.Class.PrimaryConstructor.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufClassPrimaryConstructor {
    val data = if (hasData()) this.data.toDataClass(nameResolver, enumerate) else null
    return ProtoBufClassPrimaryConstructor(data)
}

public fun ProtoBufClassPrimaryConstructor.differenceTo(other: ProtoBufClassPrimaryConstructor): EnumSet<ProtoBufClassPrimaryConstructor.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufClassPrimaryConstructor.Kind>())

    if (data != other.data) {
        result.add(ProtoBufClassPrimaryConstructor.Kind.DATA)
    }

    return result
}

public data class ProtoBufAnnotation(
    public val id: Int,
    public val argumentList: List<ProtoBufAnnotationArgument>
) {
    public enum class Kind {
        ID,
        ARGUMENT_LIST
    }
}

public fun ProtoBuf.Annotation.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufAnnotation {
    val id = this.id.fromFqNameId(nameResolver, enumerate)
    val argumentList = this.argumentList.map { it.toDataClass(nameResolver, enumerate) }
    return ProtoBufAnnotation(id, argumentList)
}

public fun ProtoBufAnnotation.differenceTo(other: ProtoBufAnnotation): EnumSet<ProtoBufAnnotation.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufAnnotation.Kind>())

    if (id != other.id) {
        result.add(ProtoBufAnnotation.Kind.ID)
    }

    if (argumentList != other.argumentList) {
        result.add(ProtoBufAnnotation.Kind.ARGUMENT_LIST)
    }

    return result
}

public data class ProtoBufCallableValueParameter(
    public val flags: Int?,
    public val name: Int,
    public val type: ProtoBufType,
    public val varargElementType: ProtoBufType?,
    public val index: Int?
) {
    public enum class Kind {
        FLAGS,
        NAME,
        TYPE,
        VARARG_ELEMENT_TYPE,
        INDEX
    }
}

public fun ProtoBuf.Callable.ValueParameter.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufCallableValueParameter {
    val flags = if (hasFlags()) this.flags else null
    val name = this.name.fromNameId(nameResolver, enumerate)
    val type = this.type.toDataClass(nameResolver, enumerate)
    val varargElementType = if (hasVarargElementType()) this.varargElementType.toDataClass(nameResolver, enumerate) else null
    val index = if (hasExtension(JvmProtoBuf.index)) this.getExtension(JvmProtoBuf.index) else null
    return ProtoBufCallableValueParameter(flags, name, type, varargElementType, index)
}

public fun ProtoBufCallableValueParameter.differenceTo(other: ProtoBufCallableValueParameter): EnumSet<ProtoBufCallableValueParameter.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufCallableValueParameter.Kind>())

    if (flags != other.flags) {
        result.add(ProtoBufCallableValueParameter.Kind.FLAGS)
    }

    if (name != other.name) {
        result.add(ProtoBufCallableValueParameter.Kind.NAME)
    }

    if (type != other.type) {
        result.add(ProtoBufCallableValueParameter.Kind.TYPE)
    }

    if (varargElementType != other.varargElementType) {
        result.add(ProtoBufCallableValueParameter.Kind.VARARG_ELEMENT_TYPE)
    }

    if (index != other.index) {
        result.add(ProtoBufCallableValueParameter.Kind.INDEX)
    }

    return result
}

public data class JvmProtoBufJvmMethodSignature(
    public val name: Int,
    public val returnType: JvmProtoBufJvmType,
    public val parameterTypeList: List<JvmProtoBufJvmType>
) {
    public enum class Kind {
        NAME,
        RETURN_TYPE,
        PARAMETER_TYPE_LIST
    }
}

public fun JvmProtoBuf.JvmMethodSignature.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): JvmProtoBufJvmMethodSignature {
    val name = this.name.fromStringId(nameResolver, enumerate)
    val returnType = this.returnType.toDataClass(nameResolver, enumerate)
    val parameterTypeList = this.parameterTypeList.map { it.toDataClass(nameResolver, enumerate) }
    return JvmProtoBufJvmMethodSignature(name, returnType, parameterTypeList)
}

public fun JvmProtoBufJvmMethodSignature.differenceTo(other: JvmProtoBufJvmMethodSignature): EnumSet<JvmProtoBufJvmMethodSignature.Kind> {
    val result = EnumSet.noneOf(javaClass<JvmProtoBufJvmMethodSignature.Kind>())

    if (name != other.name) {
        result.add(JvmProtoBufJvmMethodSignature.Kind.NAME)
    }

    if (returnType != other.returnType) {
        result.add(JvmProtoBufJvmMethodSignature.Kind.RETURN_TYPE)
    }

    if (parameterTypeList != other.parameterTypeList) {
        result.add(JvmProtoBufJvmMethodSignature.Kind.PARAMETER_TYPE_LIST)
    }

    return result
}

public data class JvmProtoBufJvmPropertySignature(
    public val field: JvmProtoBufJvmFieldSignature?,
    public val syntheticMethod: JvmProtoBufJvmMethodSignature?,
    public val getter: JvmProtoBufJvmMethodSignature?,
    public val setter: JvmProtoBufJvmMethodSignature?
) {
    public enum class Kind {
        FIELD,
        SYNTHETIC_METHOD,
        GETTER,
        SETTER
    }
}

public fun JvmProtoBuf.JvmPropertySignature.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): JvmProtoBufJvmPropertySignature {
    val field = if (hasField()) this.field.toDataClass(nameResolver, enumerate) else null
    val syntheticMethod = if (hasSyntheticMethod()) this.syntheticMethod.toDataClass(nameResolver, enumerate) else null
    val getter = if (hasGetter()) this.getter.toDataClass(nameResolver, enumerate) else null
    val setter = if (hasSetter()) this.setter.toDataClass(nameResolver, enumerate) else null
    return JvmProtoBufJvmPropertySignature(field, syntheticMethod, getter, setter)
}

public fun JvmProtoBufJvmPropertySignature.differenceTo(other: JvmProtoBufJvmPropertySignature): EnumSet<JvmProtoBufJvmPropertySignature.Kind> {
    val result = EnumSet.noneOf(javaClass<JvmProtoBufJvmPropertySignature.Kind>())

    if (field != other.field) {
        result.add(JvmProtoBufJvmPropertySignature.Kind.FIELD)
    }

    if (syntheticMethod != other.syntheticMethod) {
        result.add(JvmProtoBufJvmPropertySignature.Kind.SYNTHETIC_METHOD)
    }

    if (getter != other.getter) {
        result.add(JvmProtoBufJvmPropertySignature.Kind.GETTER)
    }

    if (setter != other.setter) {
        result.add(JvmProtoBufJvmPropertySignature.Kind.SETTER)
    }

    return result
}

public data class ProtoBufTypeArgument(
    public val projection: ProtoBuf.Type.Argument.Projection?,
    public val type: ProtoBufType?
) {
    public enum class Kind {
        PROJECTION,
        TYPE
    }
}

public fun ProtoBuf.Type.Argument.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufTypeArgument {
    val projection = if (hasProjection()) this.projection else null
    val type = if (hasType()) this.type.toDataClass(nameResolver, enumerate) else null
    return ProtoBufTypeArgument(projection, type)
}

public fun ProtoBufTypeArgument.differenceTo(other: ProtoBufTypeArgument): EnumSet<ProtoBufTypeArgument.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufTypeArgument.Kind>())

    if (projection != other.projection) {
        result.add(ProtoBufTypeArgument.Kind.PROJECTION)
    }

    if (type != other.type) {
        result.add(ProtoBufTypeArgument.Kind.TYPE)
    }

    return result
}

public data class ProtoBufAnnotationArgument(
    public val nameId: Int,
    public val value: ProtoBufAnnotationArgumentValue
) {
    public enum class Kind {
        NAME_ID,
        VALUE
    }
}

public fun ProtoBuf.Annotation.Argument.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufAnnotationArgument {
    val nameId = this.nameId.fromNameId(nameResolver, enumerate)
    val value = this.value.toDataClass(nameResolver, enumerate)
    return ProtoBufAnnotationArgument(nameId, value)
}

public fun ProtoBufAnnotationArgument.differenceTo(other: ProtoBufAnnotationArgument): EnumSet<ProtoBufAnnotationArgument.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufAnnotationArgument.Kind>())

    if (nameId != other.nameId) {
        result.add(ProtoBufAnnotationArgument.Kind.NAME_ID)
    }

    if (value != other.value) {
        result.add(ProtoBufAnnotationArgument.Kind.VALUE)
    }

    return result
}

public data class JvmProtoBufJvmType(
    public val primitiveType: JvmProtoBuf.JvmType.PrimitiveType?,
    public val classFqName: Int?,
    public val arrayDimension: Int?
) {
    public enum class Kind {
        PRIMITIVE_TYPE,
        CLASS_FQ_NAME,
        ARRAY_DIMENSION
    }
}

public fun JvmProtoBuf.JvmType.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): JvmProtoBufJvmType {
    val primitiveType = if (hasPrimitiveType()) this.primitiveType else null
    val classFqName = if (hasClassFqName()) this.classFqName.fromFqNameId(nameResolver, enumerate) else null
    val arrayDimension = if (hasArrayDimension()) this.arrayDimension else null
    return JvmProtoBufJvmType(primitiveType, classFqName, arrayDimension)
}

public fun JvmProtoBufJvmType.differenceTo(other: JvmProtoBufJvmType): EnumSet<JvmProtoBufJvmType.Kind> {
    val result = EnumSet.noneOf(javaClass<JvmProtoBufJvmType.Kind>())

    if (primitiveType != other.primitiveType) {
        result.add(JvmProtoBufJvmType.Kind.PRIMITIVE_TYPE)
    }

    if (classFqName != other.classFqName) {
        result.add(JvmProtoBufJvmType.Kind.CLASS_FQ_NAME)
    }

    if (arrayDimension != other.arrayDimension) {
        result.add(JvmProtoBufJvmType.Kind.ARRAY_DIMENSION)
    }

    return result
}

public data class JvmProtoBufJvmFieldSignature(
    public val name: Int,
    public val type: JvmProtoBufJvmType,
    public val isStaticInOuter: Boolean?
) {
    public enum class Kind {
        NAME,
        TYPE,
        IS_STATIC_IN_OUTER
    }
}

public fun JvmProtoBuf.JvmFieldSignature.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): JvmProtoBufJvmFieldSignature {
    val name = this.name.fromStringId(nameResolver, enumerate)
    val type = this.type.toDataClass(nameResolver, enumerate)
    val isStaticInOuter = if (hasIsStaticInOuter()) this.isStaticInOuter else null
    return JvmProtoBufJvmFieldSignature(name, type, isStaticInOuter)
}

public fun JvmProtoBufJvmFieldSignature.differenceTo(other: JvmProtoBufJvmFieldSignature): EnumSet<JvmProtoBufJvmFieldSignature.Kind> {
    val result = EnumSet.noneOf(javaClass<JvmProtoBufJvmFieldSignature.Kind>())

    if (name != other.name) {
        result.add(JvmProtoBufJvmFieldSignature.Kind.NAME)
    }

    if (type != other.type) {
        result.add(JvmProtoBufJvmFieldSignature.Kind.TYPE)
    }

    if (isStaticInOuter != other.isStaticInOuter) {
        result.add(JvmProtoBufJvmFieldSignature.Kind.IS_STATIC_IN_OUTER)
    }

    return result
}

public data class ProtoBufAnnotationArgumentValue(
    public val type: ProtoBuf.Annotation.Argument.Value.Type?,
    public val intValue: Long?,
    public val floatValue: Float?,
    public val doubleValue: Double?,
    public val stringValue: Int?,
    public val classId: Int?,
    public val enumValueId: Int?,
    public val annotation: ProtoBufAnnotation?,
    public val arrayElementList: List<ProtoBufAnnotationArgumentValue>
) {
    public enum class Kind {
        TYPE,
        INT_VALUE,
        FLOAT_VALUE,
        DOUBLE_VALUE,
        STRING_VALUE,
        CLASS_ID,
        ENUM_VALUE_ID,
        ANNOTATION,
        ARRAY_ELEMENT_LIST
    }
}

public fun ProtoBuf.Annotation.Argument.Value.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): ProtoBufAnnotationArgumentValue {
    val type = if (hasType()) this.type else null
    val intValue = if (hasIntValue()) this.intValue else null
    val floatValue = if (hasFloatValue()) this.floatValue else null
    val doubleValue = if (hasDoubleValue()) this.doubleValue else null
    val stringValue = if (hasStringValue()) this.stringValue.fromStringId(nameResolver, enumerate) else null
    val classId = if (hasClassId()) this.classId.fromFqNameId(nameResolver, enumerate) else null
    val enumValueId = if (hasEnumValueId()) this.enumValueId.fromNameId(nameResolver, enumerate) else null
    val annotation = if (hasAnnotation()) this.annotation.toDataClass(nameResolver, enumerate) else null
    val arrayElementList = this.arrayElementList.map { it.toDataClass(nameResolver, enumerate) }
    return ProtoBufAnnotationArgumentValue(type, intValue, floatValue, doubleValue, stringValue, classId, enumValueId, annotation, arrayElementList)
}

public fun ProtoBufAnnotationArgumentValue.differenceTo(other: ProtoBufAnnotationArgumentValue): EnumSet<ProtoBufAnnotationArgumentValue.Kind> {
    val result = EnumSet.noneOf(javaClass<ProtoBufAnnotationArgumentValue.Kind>())

    if (type != other.type) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.TYPE)
    }

    if (intValue != other.intValue) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.INT_VALUE)
    }

    if (floatValue != other.floatValue) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.FLOAT_VALUE)
    }

    if (doubleValue != other.doubleValue) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.DOUBLE_VALUE)
    }

    if (stringValue != other.stringValue) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.STRING_VALUE)
    }

    if (classId != other.classId) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.CLASS_ID)
    }

    if (enumValueId != other.enumValueId) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.ENUM_VALUE_ID)
    }

    if (annotation != other.annotation) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.ANNOTATION)
    }

    if (arrayElementList != other.arrayElementList) {
        result.add(ProtoBufAnnotationArgumentValue.Kind.ARRAY_ELEMENT_LIST)
    }

    return result
}

private fun Int.fromStringId(nameResolver: NameResolver, enumerate: (String) -> Int): Int = enumerate(nameResolver.getString(this))
private fun Int.fromNameId(nameResolver: NameResolver, enumerate: (String) -> Int): Int = enumerate(nameResolver.getString(this))
private fun Int.fromFqNameId(nameResolver: NameResolver, enumerate: (String) -> Int): Int = enumerate(nameResolver.getFqName(this).asString())
