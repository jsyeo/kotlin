/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.generators.protobuf

import com.google.protobuf.Descriptors
import org.jetbrains.kotlin.generators.util.GeneratorsFileUtil
import org.jetbrains.kotlin.serialization.DebugExtOptionsProtoBuf
import org.jetbrains.kotlin.serialization.DebugProtoBuf
import org.jetbrains.kotlin.serialization.jvm.DebugJvmProtoBuf
import org.jetbrains.kotlin.utils.Printer
import java.io.File
import kotlin.platform.platformStatic

class GenerateProtoBufCompare {
    companion object {
        val DEST_FILE: File = File("jps-plugin/src/org/jetbrains/kotlin/jps/incremental/ProtoCompareGenerated.kt")

        platformStatic
        fun main(args: Array<String>) {
            generate(DEST_FILE)
        }

        fun generate(destFile: File) {
            GeneratorsFileUtil.writeFileIfContentChanged(destFile, GenerateProtoBufCompare().generate())
        }
    }

    val extentionsMap = DebugJvmProtoBuf.getDescriptor().extensions.groupBy { it.containingType }

    val doneMessages: MutableSet<Descriptors.Descriptor> = linkedSetOf()
    val messages: MutableList<Descriptors.Descriptor> = arrayListOf()

    fun generate(): String {
        val sb = StringBuilder()
        val p = Printer(sb)
        p.println(File("license/LICENSE.txt").readText())
        p.println("package org.jetbrains.kotlin.jps.incremental")
        p.println()

        p.println("import org.jetbrains.kotlin.serialization.ProtoBuf")
        p.println("import org.jetbrains.kotlin.serialization.deserialization.NameResolver")
        p.println("import org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf")
        p.println("import java.util.EnumSet")
        p.println()
        p.println("/** This file is generated by org.jetbrains.kotlin.generators.protobuf.GenerateProtoBufCompare. DO NOT MODIFY MANUALLY */")
        p.println()

        val fileDescriptor = DebugProtoBuf.getDescriptor()

        messages.add(fileDescriptor.findMessageTypeByName("Package"))
        messages.add(fileDescriptor.findMessageTypeByName("Class"))

        while (!messages.isEmpty()) {
            val messageDescriptor = messages.remove(0)
            doneMessages.add(messageDescriptor)
            p.println()
            generateForMessage(messageDescriptor, p)
        }

        p.println()
        generatePredefined(p)

        return sb.toString()
    }

    fun generatePredefined(p: Printer) {
        p.println("private fun Int.fromStringId(nameResolver: NameResolver, enumerate: (String) -> Int): Int = enumerate(nameResolver.getString(this))")
        p.println("private fun Int.fromNameId(nameResolver: NameResolver, enumerate: (String) -> Int): Int = enumerate(nameResolver.getString(this))")
        p.println("private fun Int.fromFqNameId(nameResolver: NameResolver, enumerate: (String) -> Int): Int = enumerate(nameResolver.getFqName(this).asString())")
    }

    fun generateForMessage(descriptor: Descriptors.Descriptor, p: Printer) {
        val typeName = descriptor.typeName()
        val className = typeName.replace(".", "")

        p.println("public data class $className(")

        val fields = descriptor.fields.filter { !it.isSkip() }
        val extFields = extentionsMap[descriptor]?.filter { !it.isSkip() } ?: emptyList()
        val allFields = fields + extFields

        p.println(allFields.map { "    public val ${it.toValName()}: ${it.toClassParameterType()}"}.join(",\n"))
        p.println(") {")
        p.println("    public enum class Kind {")
        p.println(allFields.map { "        " + it.toEnumName() }.join(",\n"))
        p.println("    }")

        p.println("}")
        p.println()

        p.println("public fun $typeName.toDataClass(nameResolver: NameResolver, enumerate: (String) -> Int): $className {")
        p.pushIndent()

        fields.forEach { field -> generateValForField(field, p) }

        extFields.forEach { field -> generateValForExtField(field, p) }

        val args = allFields.map { it.toValName() }.join(", ")
        p.println("return $className($args)")

        p.popIndent()
        p.println("}")

        p.println()
        p.println("public fun $className.differenceTo(other: $className): EnumSet<$className.Kind> {")
        p.pushIndent()

        p.println("val result = EnumSet.noneOf(javaClass<$className.Kind>())")

        allFields.forEach { field ->
            p.println()
            p.println("if (${field.toValName()} != other.${field.toValName()}) {")
            p.println("    result.add($className.Kind.${field.toEnumName()})")
            p.println("}")
        }

        p.println()
        p.println("return result")
        p.popIndent()
        p.println("}")

        allFields.forEach { addMessageTypeToProcessIfNeeded(it) }
    }

    fun generateValForField(field: Descriptors.FieldDescriptor, p: Printer) {
        val fieldName = field.toValName()
        val suffix = field.optConvertSuffix()
        when {
            field.isRequired ->
                p.println("val $fieldName = this.$fieldName$suffix")
            field.isOptional ->
                p.println("val $fieldName = if (has${fieldName.capitalize()}()) this.$fieldName$suffix else null")
            field.isRepeated ->
                if (suffix.isEmpty()) {
                    p.println("val $fieldName = this.$fieldName")
                }
                else {
                    p.println("val $fieldName = this.$fieldName.map { it$suffix }")
                }
            else ->
                throw UnsupportedOperationException("Unsupported field kind: ${field.name}")
        }
    }

    fun generateValForExtField(field: Descriptors.FieldDescriptor, p: Printer) {
        val outerClassName = field.file.options.javaOuterClassname.removePrefix("Debug")
        val fullFieldName = "$outerClassName.${field.name.toJavaName()}"
        val fieldName = field.toValName()

        val suffix = field.optConvertSuffix()
        when {
            field.isRequired ->
                p.println("val $fieldName = this.getExtension($fullFieldName)$suffix")
            field.isOptional ->
                p.println("val $fieldName = if (hasExtension($fullFieldName)) this.getExtension($fullFieldName)$suffix else null")
            field.isRepeated -> {
                p.println("val $fieldName = arrayListOf<${field.toJavaType()}>()")
                p.println("for(i in 0..getExtensionCount($fullFieldName) - 1) {")
                p.println("    $fieldName.add(getExtension($fullFieldName, i)$suffix)")
                p.println("}")
                p.println()
            }
            else ->
                throw UnsupportedOperationException("Unsupported field kind: ${field.name}")
        }
    }

    fun Descriptors.FieldDescriptor.optConvertSuffix(): String =
        when {
            options.getExtension(DebugExtOptionsProtoBuf.stringIdInTable) ->
                ".fromStringId(nameResolver, enumerate)"
            options.getExtension(DebugExtOptionsProtoBuf.nameIdInTable) ->
                ".fromNameId(nameResolver, enumerate)"
            options.getExtension(DebugExtOptionsProtoBuf.fqNameIdInTable) ->
                ".fromFqNameId(nameResolver, enumerate)"
            javaType == Descriptors.FieldDescriptor.JavaType.MESSAGE ->
                ".toDataClass(nameResolver, enumerate)"
            else ->
                ""
        }

    fun Descriptors.FieldDescriptor.toClassParameterType(): String =
        when {
            isRequired ->
                toJavaType()
            isOptional ->
                toJavaType() + "?"
            isRepeated ->
                "List<${toJavaType()}>"
            else ->
                throw UnsupportedOperationException("Unsupported field kind: $name")
        }

    private fun Descriptors.FieldDescriptor.toJavaType(): String =
        when (javaType!!) {
            Descriptors.FieldDescriptor.JavaType.INT ->
                "Int"
            Descriptors.FieldDescriptor.JavaType.LONG ->
                "Long"
            Descriptors.FieldDescriptor.JavaType.FLOAT ->
                "Float"
            Descriptors.FieldDescriptor.JavaType.DOUBLE ->
                "Double"
            Descriptors.FieldDescriptor.JavaType.BOOLEAN ->
                "Boolean"
            Descriptors.FieldDescriptor.JavaType.STRING ->
                "String"
            Descriptors.FieldDescriptor.JavaType.BYTE_STRING ->
                throw UnsupportedOperationException(toString())
            Descriptors.FieldDescriptor.JavaType.ENUM ->
                enumType.typeName()
            Descriptors.FieldDescriptor.JavaType.MESSAGE ->
                messageType.typeName().replace(".", "")
        }

    private fun Descriptors.FieldDescriptor.toValName(): String = name.toJavaName() + (if (isRepeated) "List" else "")
    private fun Descriptors.FieldDescriptor.isSkip(): Boolean = this.options.getExtension(DebugExtOptionsProtoBuf.skipInComparison)

    private fun addMessageTypeToProcessIfNeeded(field: Descriptors.FieldDescriptor) {
        if (field.javaType == Descriptors.FieldDescriptor.JavaType.MESSAGE &&
            !doneMessages.contains(field.messageType) && !messages.contains(field.messageType)) {
            messages.add(field.messageType)
        }
    }

    private fun Descriptors.Descriptor.typeName(): String = typeName(file, fullName)
    private fun Descriptors.EnumDescriptor.typeName(): String = typeName(file, fullName)

    private fun typeName(file: Descriptors.FileDescriptor, fullName: String): String {
        val outerClassName = file.options.javaOuterClassname.removePrefix("Debug")
        val packageHeader = file.`package`
        return outerClassName + fullName.removePrefix(packageHeader)
    }

    private fun Descriptors.FieldDescriptor.toEnumName() = toValName().toEnumName()

    private fun String.toJavaName() = this.split("_").map { it.capitalize() }.join("").decapitalize()
    private fun String.toEnumName() = replace("[A-Z]".toRegex()) { "_" + it.value }.toUpperCase()
}